<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –ö–ª–∏–∫–µ—Ä</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    * {
      box-sizing: border-box;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    body {
      font-family: 'Orbitron', 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
      background: #000;
      width: 100vw;
      height: 100vh;
    }
    /* –ú–æ–±–∏–ª—å–Ω–∞—è –∞–¥–∞–ø—Ç–∞—Ü–∏—è UI */
    #header {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      text-align: center;
      z-index: 20;
      padding: 8px 50px 8px 0;
      backdrop-filter: blur(6px);
      border-bottom: 1px solid;
      background: rgba(0, 0, 0, 0.5);
    }
    #gameTitle { 
      margin: 0; 
      font-size: clamp(1.1em, 4vw, 1.4em); 
      color: white;
    }
    /* –û–ë–ù–û–í–õ–ï–ù–ù–û–ï –†–ê–°–ü–û–õ–û–ñ–ï–ù–ò–ï HUD - –°–õ–ï–í–ê –ü–û–î –ó–ê–ì–û–õ–û–í–ö–û–ú */
    #hud-left {
      position: absolute;
      top: 50px;
      left: 10px;
      z-index: 25;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    .hud-item {
      font-size: clamp(0.7em, 3vw, 0.8em);
      text-shadow: 0 0 3px;
      color: white;
      white-space: nowrap;
    }
    #coins { color: #d7ccc8; }
    #clickPowerInfo { color: #a0d2ff; }
    #helperTimer { color: #69f0ae; }
    #critChanceInfo { color: #ffd700; }
    #critMultiplierInfo { color: #ffd700; }
    
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä */
    #progressContainer {
      position: absolute;
      top: 145px;
      left: 10px;
      width: min(200px, 50vw);
      height: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      overflow: hidden;
      z-index: 25;
    }
    
    #progressText {
      position: absolute;
      top: 157px;
      left: 10px;
      font-size: clamp(0.6em, 2.5vw, 0.7em);
      color: #a0d2ff;
      text-shadow: 0 0 3px rgba(160,210,255,0.6);
      z-index: 25;
    }

    /* –ö–Ω–æ–ø–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è */
    #saveBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      font-size: 1.2em;
      cursor: pointer;
      z-index: 30;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
      color: #4CAF50;
      transition: transform 0.1s;
    }
    #saveBtn:active { transform: scale(0.92); }

    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ —É–ª—É—á—à–µ–Ω–∏–π */
    .upgrade-btn {
      position: absolute;
      right: 10px;
      width: clamp(48px, 12vw, 52px);
      height: clamp(48px, 12vw, 52px);
      border: none;
      border-radius: 8px;
      font-size: clamp(1.1em, 4vw, 1.3em);
      cursor: pointer;
      z-index: 30;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: transform 0.1s;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      padding: 3px;
      overflow: hidden;
    }
    .upgrade-btn:active { transform: scale(0.92); }
    #upgradeClickBtn { bottom: 75px; }
    #upgradeHelperBtn { bottom: 135px; }
    #upgradeCritChanceBtn { bottom: 195px; }
    #upgradeCritMultBtn { bottom: 255px; }
    #upgradeHelperDmgBtn { bottom: 315px; }
    
    .upgrade-cost {
      font-size: clamp(0.5em, 2.5vw, 0.55em);
      margin-top: 1px;
      font-weight: bold;
      text-shadow: 0 0 2px rgba(0,0,0,0.8);
    }
    
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –±–ª–æ–∫–∏ */
    .moving-block {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      font-weight: bold;
      font-size: clamp(0.8em, 4vw, 0.9em);
      font-family: 'Orbitron', monospace;
      transition: transform 0.1s;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
      overflow: hidden;
      min-width: 60px;
      min-height: 60px;
    }
    
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —ç–∫—Ä–∞–Ω—ã */
    #welcomeScreen, #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
      text-align: center;
      padding: 15px;
      box-sizing: border-box;
    }
    
    #welcomeScreen h2 {
      font-size: clamp(1.5em, 6vw, 2em);
      margin-bottom: 15px;
    }
    
    #welcomeScreen p {
      max-width: 95%;
      text-align: center;
      margin: 8px 0;
      line-height: 1.4;
      font-size: clamp(0.9em, 3.5vw, 1em);
    }
    
    .btn {
      padding: clamp(10px, 3vw, 12px) clamp(25px, 6vw, 30px);
      margin-top: 15px;
      font-size: clamp(1em, 4vw, 1.1em);
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      transition: transform 0.1s;
      min-height: 44px; /* –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –∫–∞—Å–∞–Ω–∏—è */
    }
    
    #continueBtn {
      background: #2196F3;
      margin-bottom: 10px;
    }
    
    #gameOverScreen h2 {
      font-size: clamp(1.6em, 6vw, 2.2em);
      margin-bottom: 15px;
    }
    
    #finalScore { font-size: clamp(1.1em, 4vw, 1.4em); margin-bottom: 15px; }
    
    #restartBtn, #shareBtn, #dailyRewardBtn {
      padding: clamp(8px, 2.5vw, 10px) clamp(20px, 5vw, 24px);
      margin: 6px;
      font-size: clamp(0.9em, 3.5vw, 1em);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      transition: transform 0.1s;
      min-height: 44px;
    }
    
    /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —Ç–µ–∫—Å—Ç—ã —É—Ä–æ–Ω–∞ - –û–ë–ù–û–í–õ–ï–ù–û: –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ */
    .damage-text {
      font-size: clamp(1em, 4vw, 1.1em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      opacity: 1;
      transition: transform 0.5s, opacity 0.5s;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
      max-width: 100px;
      text-align: center;
    }
    
    .combo-text {
      font-size: clamp(1.4em, 5vw, 1.8em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      animation: comboPop 0.5s ease-out;
      font-family: 'Orbitron', monospace;
      max-width: 150px;
      text-align: center;
    }
    
    .reward-text {
      font-size: clamp(1.1em, 4vw, 1.3em);
      position: absolute;
      pointer-events: none;
      z-index: 15;
      animation: rewardFloat 1.5s ease-out;
      font-family: 'Orbitron', monospace;
      max-width: 120px;
      text-align: center;
    }
    
    /* –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è landscape —Ä–µ–∂–∏–º–∞ */
    @media (max-height: 500px) and (orientation: landscape) {
      #header {
        padding: 4px 40px 4px 0;
      }
      
      #hud-left {
        top: 40px;
        left: 8px;
        gap: 2px;
      }
      
      .upgrade-btn {
        width: 40px;
        height: 40px;
        right: 8px;
      }
      
      #upgradeClickBtn { bottom: 60px; }
      #upgradeHelperBtn { bottom: 110px; }
      #upgradeCritChanceBtn { bottom: 160px; }
      #upgradeCritMultBtn { bottom: 210px; }
      #upgradeHelperDmgBtn { bottom: 260px; }
      
      #progressContainer {
        top: 120px;
        left: 8px;
        width: 150px;
        height: 8px;
      }
      
      #progressText {
        top: 130px;
        left: 8px;
        font-size: 0.6em;
      }
    }

    /* –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
    /* –§–æ–Ω—ã –ª–æ–∫–∞—Ü–∏–π */
    #location-mercury, #location-venus, #location-earth, #location-mars {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
    }
    #location-mercury.active, #location-venus.active, #location-earth.active, #location-mars.active {
      opacity: 1;
      pointer-events: auto;
    }
    #location-jupiter, #location-saturn, #location-uranus, #location-neptune, #location-pluto {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
    }
    #location-jupiter.active, #location-saturn.active, #location-uranus.active, #location-neptune.active, #location-pluto.active {
      opacity: 1;
      pointer-events: auto;
    }
    #cyberGrid {
      position: absolute;
      top: 0;
      left: 0;
      width: 200%;
      height: 200%;
      background: 
        linear-gradient(rgba(76, 0, 130, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(76, 0, 130, 0.1) 1px, transparent 1px);
      background-size: 40px 40px;
      transform: translate(-25%, -25%);
      animation: cyberMove 20s linear infinite;
    }
    @keyframes cyberMove {
      0% { transform: translate(-25%, -25%) scale(1); }
      100% { transform: translate(-25%, -25%) scale(1.2); }
    }
    
    #progressBar {
      height: 100%;
      background: linear-gradient(90deg, #bb86fc, #4a55e0);
      border-radius: 6px;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    #gameArea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 5;
    }
    
    .crack-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background-image: 
        radial-gradient(circle at 30% 30%, transparent 60%, rgba(0,0,0,0.3) 65%),
        radial-gradient(circle at 70% 70%, transparent 60%, rgba(0,0,0,0.3) 65%),
        radial-gradient(circle at 50% 20%, transparent 60%, rgba(0,0,0,0.3) 65%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .crack-1 { opacity: 0.3; }
    .crack-2 { opacity: 0.6; }
    .crack-3 { opacity: 0.9; }
    #levelAnnounce {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(1.2em, 5vw, 1.5em);
      font-weight: bold;
      z-index: 40;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      color: white;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }
    
    .upgrade-btn.btn-available { 
      background: linear-gradient(135deg, #4CAF50, #388E3C); 
      color: white; 
    }
    .upgrade-btn.btn-unavailable { 
      background: linear-gradient(135deg, #666, #444); 
      color: #ccc; 
      cursor: not-allowed; 
      opacity: 0.7;
    }
    
    .tooltip {
      position: absolute;
      bottom: 70px;
      right: 15px;
      padding: 5px 8px;
      border-radius: 6px;
      font-size: clamp(0.75em, 3vw, 0.85em);
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      z-index: 35;
    }
    #particlesCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 6;
    }
    
    @keyframes comboPop {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    @keyframes rewardFloat {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-50px); opacity: 0; }
    }
    
    .helper {
      position: absolute;
      width: 35px;
      height: 35px;
      background: radial-gradient(circle, #69f0ae, #00e676);
      border-radius: 50%;
      z-index: 12;
      pointer-events: none;
      box-shadow: 0 0 15px #69f0ae;
      animation: helperFloat 3s ease-in-out infinite;
    }
    
    @keyframes helperFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }
    
    .helper-beam {
      position: absolute;
      width: 3px;
      background: linear-gradient(to top, transparent, #69f0ae);
      z-index: 11;
      pointer-events: none;
      animation: beamPulse 0.5s ease-out;
    }
    
    @keyframes beamPulse {
      0% { height: 0; opacity: 1; }
      100% { height: 100px; opacity: 0; }
    }
    
    #welcomeScreen { 
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    }
    
    #gameOverScreen {
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
    }
    
    #restartBtn { background: #4CAF50; color: white; }
    #shareBtn { background: #00c853; color: white; }
    #dailyRewardBtn { background: #ffeb3b; color: #000; }
    
    /* –°—Ç–∏–ª–∏ –¥–ª—è —Ä–µ–¥–∫–∏—Ö –±–ª–æ–∫–æ–≤ */
    .block-gold {
        background: linear-gradient(135deg, #ffd700, #ff6b00) !important;
        animation: gold-shimmer 3s infinite;
    }
    .block-rainbow {
        background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00ffff, #0000ff, #8b00ff) !important;
        background-size: 400% 400%;
        animation: rainbow 3s ease infinite;
    }
    .block-crystal {
        background: linear-gradient(45deg, #00ffff, #ffffff, #00ffff) !important;
        box-shadow: 0 0 25px #00ffff, 0 0 10px #ffffff inset !important;
        animation: crystalPulse 2s ease-in-out infinite !important;
    }
    .block-mystery {
        background: linear-gradient(45deg, #9b59b6, #e74c3c, #3498db) !important;
        background-size: 300% 300% !important;
        box-shadow: 0 0 20px rgba(155, 89, 182, 0.7) !important;
        animation: mysteryShift 4s ease-in-out infinite !important;
    }
    
    @keyframes gold-shimmer {
        0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 5px rgba(255, 107, 0, 0.3) inset; }
        50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 10px rgba(255, 107, 0, 0.6) inset; }
        100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5), 0 0 5px rgba(255, 107, 0, 0.3) inset; }
    }
    @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
    }
    @keyframes crystalPulse {
        0%, 100% { transform: translateX(-50%) scale(1); }
        50% { transform: translateX(-50%) scale(1.05); }
    }
    @keyframes mysteryShift {
        0%, 100% { background-position: 0% 50%; filter: hue-rotate(0deg); }
        50% { background-position: 100% 50%; filter: hue-rotate(180deg); }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- –õ–æ–∫–∞—Ü–∏–∏ —Å Canvas -->
  <div id="location-mercury" class="location active">
    <canvas id="starsCanvas"></canvas>
  </div>
  <div id="location-venus" class="location">
    <canvas id="lavaCanvas"></canvas>
  </div>
  <div id="location-earth" class="location">
    <canvas id="iceCanvas"></canvas>
  </div>
  <div id="location-mars" class="location">
    <canvas id="bioCanvas"></canvas>
  </div>
  <div id="location-jupiter" class="location">
    <div id="cyberGrid"></div>
  </div>
  <div id="location-saturn" class="location">
    <div id="cyberGrid"></div>
  </div>
  <div id="location-uranus" class="location">
    <div id="cyberGrid"></div>
  </div>
  <div id="location-neptune" class="location">
    <div id="cyberGrid"></div>
  </div>
  <div id="location-pluto" class="location">
    <div id="cyberGrid"></div>
  </div>
  <!-- UI -->
  <div id="header">
    <h2 id="gameTitle">‚òø –ú–µ—Ä–∫—É—Ä–∏–π</h2>
  </div>
  
  <!-- –ö–Ω–æ–ø–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è -->
  <button id="saveBtn" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–≥—Ä—É">
    <i class="fas fa-save"></i>
  </button>
  
  <!-- –û–ë–ù–û–í–õ–ï–ù–ù–´–ô HUD - –°–õ–ï–í–ê –ü–û–î –ó–ê–ì–û–õ–û–í–ö–û–ú -->
  <div id="hud-left">
    <div id="coins" class="hud-item">–ö—Ä–∏—Å—Ç–∞–ª–ª—ã: 0</div>
    <div id="clickPowerInfo" class="hud-item">–°–∏–ª–∞: 1</div>
    <div id="helperTimer" class="hud-item">Bobo: ‚Äî</div>
    <div id="critChanceInfo" class="hud-item">–ö—Ä–∏—Ç: 1%</div>
    <div id="critMultiplierInfo" class="hud-item">–ú–Ω–æ–∂: x2.0</div>
  </div>
  
  <!-- –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä -->
  <div id="progressContainer">
    <div id="progressBar"></div>
  </div>
  <div id="progressText">–ü—Ä–æ–≥—Ä–µ—Å—Å: 0.00000/0.38710 –∞.–µ.</div>
  
  <div id="gameArea"></div>
  <div id="levelAnnounce"></div>
  
  <!-- –ö–ù–û–ü–ö–ò –£–õ–£–ß–®–ï–ù–ò–ô -->
  <button id="upgradeClickBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-hammer"></i>
    <div class="upgrade-cost">80</div>
  </button>
  <button id="upgradeHelperBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-robot"></i>
    <div class="upgrade-cost">1500</div>
  </button>
  <button id="upgradeCritChanceBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-dice"></i>
    <div class="upgrade-cost">500</div>
  </button>
  <button id="upgradeCritMultBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-star"></i>
    <div class="upgrade-cost">800</div>
  </button>
  <button id="upgradeHelperDmgBtn" class="upgrade-btn btn-unavailable">
    <i class="fas fa-bolt"></i>
    <div class="upgrade-cost">1000</div>
  </button>
  
  <div id="tooltip" class="tooltip"></div>
  <canvas id="particlesCanvas"></canvas>
  
  <!-- –ó–≤—É–∫–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã -->
  <audio id="clickSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="breakSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="upgradeSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="comboSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  <audio id="helperSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav">
  </audio>
  
  <div id="welcomeScreen">
    <h2>üöÄ –ö–û–°–ú–ò–ß–ï–°–ö–ò–ô –ö–õ–ò–ö–ï–†</h2>
    <p>–†–∞–∑—Ä—É—à–∞–π—Ç–µ –≤–æ—Å—Ö–æ–¥—è—â–∏–µ –±–ª–æ–∫–∏ –∏ —Å–æ–±–∏—Ä–∞–π—Ç–µ <strong>–∫–æ—Å–º–∏—á–µ—Å–∫–∏–µ –ö—Ä–∏—Å—Ç–∞–ª–ª—ã</strong>!</p>
    <p>–ö–∞–∂–¥—ã–π –±–ª–æ–∫ —Ç—Ä–µ–±—É–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É–¥–∞—Ä–æ–≤ –¥–ª—è —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è.</p>
    <p><strong>–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞:</strong></p>
    <p>üåå <strong>–ê—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –µ–¥–∏–Ω–∏—Ü—ã</strong> ‚Äî –ø–µ—Ä–µ–º–µ—â–∞–π—Ç–µ—Å—å –ø–æ –°–æ–ª–Ω–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ</p>
    <p>ü™ê <strong>9 —Ä–µ–∞–ª—å–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç</strong> ‚Äî –æ—Ç –ú–µ—Ä–∫—É—Ä–∏—è –¥–æ –ü–ª—É—Ç–æ–Ω–∞</p>
    <p>üöÄ <strong>–£–ª—É—á—à–µ–Ω–∏—è</strong> ‚Äî —É–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Å–∏–ª—É, –∫—Ä–∏—Ç—ã –∏ –∞–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –ø–æ–º–æ—â–Ω–∏–∫–∞</p>
    <p>‚ú® <strong>–†–µ–¥–∫–∏–µ –±–ª–æ–∫–∏</strong> ‚Äî –¥–∞—é—Ç –±–æ–Ω—É—Å—ã –∏ –æ–≥—Ä–æ–º–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã!</p>
    <button id="continueBtn" class="btn" style="display:none;">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    <button id="startBtn" class="btn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  </div>
  
  <div id="gameOverScreen">
    <h2>–î–û–ë–´–ß–ê –ü–†–ï–†–í–ê–ù–ê!</h2>
    <div id="finalScore">–í—Å–µ–≥–æ —É—Ä–æ–Ω–∞: 0</div>
    <button id="restartBtn">–ù–æ–≤–∞—è –¥–æ–±—ã—á–∞</button>
    <button id="shareBtn">–ü–æ–¥–µ–ª–∏—Ç—å—Å—è</button>
    <button id="dailyRewardBtn">üéÅ –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞</button>
  </div>

  <script>
    // === –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –î–õ–Ø –ú–û–ë–ò–õ–¨–ù–´–• –£–°–¢–†–û–ô–°–¢–í ===
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // === –†–ï–ê–õ–¨–ù–´–ï –†–ê–°–°–¢–û–Ø–ù–ò–Ø –ü–õ–ê–ù–ï–¢ –í –ê–°–¢–†–û–ù–û–ú–ò–ß–ï–°–ö–ò–• –ï–î–ò–ù–ò–¶–ê–• ===
    // 1 –∞.–µ. = 149 597 870,7 –∫–º (–ø—Ä–∏–Ω–∏–º–∞–µ–º 1 –∫–º = 1 –µ–¥–∏–Ω–∏—Ü–∞ —É—Ä–æ–Ω–∞)
    const astronomicalUnits = {
        mercury: 0.38710,   // 57.9 –º–ª–Ω –∫–º
        venus: 0.72333,     // 108.2 –º–ª–Ω –∫–º  
        earth: 1.00000,     // 149.6 –º–ª–Ω –∫–º
        mars: 1.52366,      // 227.9 –º–ª–Ω –∫–º
        jupiter: 5.20336,   // 778.3 –º–ª–Ω –∫–º
        saturn: 9.53707,    // 1.429 –º–ª—Ä–¥ –∫–º
        uranus: 19.19126,   // 2.871 –º–ª—Ä–¥ –∫–º
        neptune: 30.06896,  // 4.498 –º–ª—Ä–¥ –∫–º
        pluto: 39.48200     // 5.906 –º–ª—Ä–¥ –∫–º
    };

    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∞.–µ. –≤ —É—Ä–æ–Ω (1 –∞.–µ. = 1 000 000 —É—Ä–æ–Ω–∞ –¥–ª—è –±–∞–ª–∞–Ω—Å–∞)
    const AU_TO_DAMAGE = 1000000;
    
    const locationRequirements = {
        mercury: { 
            damageRequired: 0, 
            nextLocation: 'venus',
            au: astronomicalUnits.mercury
        },
        venus: { 
            damageRequired: Math.round(astronomicalUnits.venus * AU_TO_DAMAGE), 
            nextLocation: 'earth',
            au: astronomicalUnits.venus
        },
        earth: { 
            damageRequired: Math.round(astronomicalUnits.earth * AU_TO_DAMAGE), 
            nextLocation: 'mars',
            au: astronomicalUnits.earth
        },
        mars: { 
            damageRequired: Math.round(astronomicalUnits.mars * AU_TO_DAMAGE), 
            nextLocation: 'jupiter',
            au: astronomicalUnits.mars
        },
        jupiter: { 
            damageRequired: Math.round(astronomicalUnits.jupiter * AU_TO_DAMAGE), 
            nextLocation: 'saturn',
            au: astronomicalUnits.jupiter
        },
        saturn: { 
            damageRequired: Math.round(astronomicalUnits.saturn * AU_TO_DAMAGE), 
            nextLocation: 'uranus',
            au: astronomicalUnits.saturn
        },
        uranus: { 
            damageRequired: Math.round(astronomicalUnits.uranus * AU_TO_DAMAGE), 
            nextLocation: 'neptune',
            au: astronomicalUnits.uranus
        },
        neptune: { 
            damageRequired: Math.round(astronomicalUnits.neptune * AU_TO_DAMAGE), 
            nextLocation: 'pluto',
            au: astronomicalUnits.neptune
        },
        pluto: { 
            damageRequired: Math.round(astronomicalUnits.pluto * AU_TO_DAMAGE), 
            nextLocation: null,
            au: astronomicalUnits.pluto
        }
    };

    // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò –°–ö–û–†–û–°–¢–ò ===
    let blockSpeed = isMobile ? 25 : 20;
    
    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –±–ª–æ–∫–∞ —Å —É—á–µ—Ç–æ–º –ª–æ–∫–∞—Ü–∏–∏
    function getCurrentSpeed() {
        const baseSpeed = blockSpeed;
        const locationIndex = Object.keys(locationRequirements).indexOf(currentLocation);
        
        // –£–º–µ–Ω—å—à–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –ø–µ—Ä–≤—ã—Ö —Ç—Ä–µ—Ö –ª–æ–∫–∞—Ü–∏–π –Ω–∞ 15%
        if (locationIndex < 3) {
            return baseSpeed * 0.85;
        }
        return baseSpeed;
    }

    // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –°–¢–û–ò–ú–û–°–¢–ò –£–õ–£–ß–®–ï–ù–ò–ô ===
    const baseClickUpgradeCost = 80;
    const baseHelperUpgradeCost = 1500;
    const baseCritChanceCost = 500;
    const baseCritMultiplierCost = 800;
    const baseHelperDmgCost = 1000;

    // === –°–ò–°–¢–ï–ú–ê –†–ï–î–ö–ò–• –ë–õ–û–ö–û–í ===
    const rareBlocks = {
        GOLD: {
            name: "–ó–æ–ª–æ—Ç–æ–π",
            chance: 0.03,
            multiplier: 8,
            healthMultiplier: 1.8,
            effect: "–ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å",
            className: "block-gold"
        },
        RAINBOW: {
            name: "–†–∞–¥—É–∂–Ω—ã–π", 
            chance: 0.02,
            multiplier: 5,
            healthMultiplier: 1.5,
            effect: "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å–∏–ª—ã",
            className: "block-rainbow"
        },
        CRYSTAL: {
            name: "–ö—Ä–∏—Å—Ç–∞–ª—å–Ω—ã–π",
            chance: 0.025,
            multiplier: 6,
            healthMultiplier: 1.6,
            effect: "–í—Ä–µ–º—è –ø–æ–º–æ—â–Ω–∏–∫–∞",
            className: "block-crystal"
        },
        MYSTERY: {
            name: "–ó–∞–≥–∞–¥–æ—á–Ω—ã–π",
            chance: 0.015,
            multiplier: 10,
            healthMultiplier: 2.0,
            effect: "–°–ª—É—á–∞–π–Ω—ã–π –±–æ–Ω—É—Å",
            className: "block-mystery"
        }
    };

    const balanceConfig = {
        baseHealth: 80,
        targetClicks: 70,
        healthRandomRange: { min: 0.8, max: 1.3 },
        
        damageProgression: {
            baseMultiplier: 1.15,
            diminishingReturns: 0.96,
            maxLevelEffect: 60
        },
        
        rewardMultiplier: 2.5,
        comboMultiplier: 0.25,
        randomBonusRange: { min: 0.8, max: 1.5 }
    };

    // –û–±—ä—è–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–π
    let stars = [], lavaParticles = [], snowflakes = [], bioDots = [];

    // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
    let coins = 0;
    let totalDamageDealt = 0;
    let clickPower = 1;
    let clickUpgradeLevel = 0;
    let gameActive = false;
    let currentLocation = 'mercury';
    let currentBlockHealth = 0;
    let currentBlock = null;
    let comboCount = 0;
    let lastDestroyTime = 0;
    const COMBO_TIME_WINDOW = isMobile ? 1500 : 2000;
    let helperActive = false;
    let helperTimeLeft = 0;
    const helperDuration = 60000;
    let helperInterval;
    let helperUpgradeLevel = 0;
    const helperUpgradeMultiplier = 1.8;
    let critChance = 0.01;
    let critMultiplier = 2.0;
    let helperDamageBonus = 0.3;

    const gameMetrics = {
        startTime: Date.now(),
        blocksDestroyed: 0,
        upgradesBought: 0,
        totalClicks: 0,
        sessions: parseInt(localStorage.getItem('gameSessions') || '0') + 1
    };

    // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –ë–ê–õ–ê–ù–°–ò–†–û–í–ö–ò ===
    function calculateBlockHealth() {
        const location = locationRequirements[currentLocation];
        const locationBonus = 1 + (location.damageRequired / 100000);
        
        let baseHealth = balanceConfig.baseHealth * locationBonus;
        
        const targetHealth = clickPower * balanceConfig.targetClicks;
        
        const combinedHealth = (baseHealth + targetHealth) / 2;
        
        const randomFactor = balanceConfig.healthRandomRange.min + 
                            Math.random() * (balanceConfig.healthRandomRange.max - balanceConfig.healthRandomRange.min);
        
        return Math.floor(combinedHealth * randomFactor);
    }

    function calculateClickPower() {
        const basePower = 1;
        const upgradeBonus = clickUpgradeLevel;
        
        const diminishingEffect = Math.pow(balanceConfig.damageProgression.diminishingReturns, 
                                         Math.min(clickUpgradeLevel, balanceConfig.damageProgression.maxLevelEffect));
        
        const nonLinearGrowth = Math.sqrt(clickUpgradeLevel + 1);
        
        return basePower + (upgradeBonus * diminishingEffect * nonLinearGrowth * balanceConfig.damageProgression.baseMultiplier);
    }

    function getExpectedClicks(blockHealth, playerDamage) {
        return Math.ceil(blockHealth / playerDamage);
    }

    function getRareBlockType() {
        const rand = Math.random();
        let cumulativeChance = 0;
        for (const [type, block] of Object.entries(rareBlocks)) {
            cumulativeChance += block.chance;
            if (rand <= cumulativeChance) {
                return type;
            }
        }
        return null;
    }

    function announceRareBlock(blockName) {
        const announce = document.createElement('div');
        announce.className = 'rare-block-announce';
        announce.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8em;
            font-weight: bold;
            color: gold;
            z-index: 50;
            text-shadow: 0 0 10px black;
            animation: fadeInOut 2s;
        `;
        announce.textContent = `üåü ${blockName} –±–ª–æ–∫! üåü`;
        document.body.appendChild(announce);
        setTimeout(() => {
            if (announce.parentNode) {
                document.body.removeChild(announce);
            }
        }, 2000);
    }

    // === –£–õ–£–ß–®–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –°–û–•–†–ê–ù–ï–ù–ò–Ø ===
    function saveGame() {
      const saveData = {
        coins,
        clickPower,
        clickUpgradeLevel,
        critChance,
        critMultiplier,
        helperDamageBonus,
        helperUpgradeLevel,
        totalDamageDealt,
        currentLocation,
        lastDailyReward: localStorage.getItem('lastDailyReward'),
        gameActive: true // –ü–æ–º–µ—á–∞–µ–º, —á—Ç–æ –∏–≥—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞
      };
      localStorage.setItem('cosmicBlocksSave', JSON.stringify(saveData));
      showTooltip('–ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!');
      setTimeout(hideTooltip, 1500);
    }
    
    function loadGame() {
      const saved = localStorage.getItem('cosmicBlocksSave');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          coins = data.coins || 0;
          clickPower = data.clickPower || 1;
          clickUpgradeLevel = data.clickUpgradeLevel || 0;
          critChance = data.critChance || 0.01;
          critMultiplier = data.critMultiplier || 2.0;
          helperDamageBonus = data.helperDamageBonus || 0.3;
          helperUpgradeLevel = data.helperUpgradeLevel || 0;
          totalDamageDealt = data.totalDamageDealt || 0;
          currentLocation = data.currentLocation || 'mercury';
          
          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å" –µ—Å–ª–∏ –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
          if (data.gameActive && document.getElementById('continueBtn')) {
            document.getElementById('continueBtn').style.display = 'block';
          }
        } catch (e) {
          console.warn('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è', e);
        }
      }
    }
    
    function checkDailyReward() {
      const now = Date.now();
      const last = localStorage.getItem('lastDailyReward');
      if (!last || now - parseInt(last) >= 24 * 60 * 60 * 1000) {
        coins += 1000;
        updateCoins();
        localStorage.setItem('lastDailyReward', now.toString());
        showTooltip('üéÅ +1000 –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤!');
        setTimeout(hideTooltip, 2000);
        saveGame();
        return true;
      } else {
        const hoursLeft = Math.ceil((24 * 60 * 60 * 1000 - (now - parseInt(last))) / (1000 * 60 * 60));
        showTooltip(`–ù–∞–≥—Ä–∞–¥–∞ —á–µ—Ä–µ–∑ ${hoursLeft} —á.`);
        setTimeout(hideTooltip, 2000);
        return false;
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
        // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã DOM
        const DOMElements = {
            coinsDisplay: document.getElementById("coins"),
            clickPowerDisplay: document.getElementById("clickPowerInfo"),
            helperTimerDisplay: document.getElementById("helperTimer"),
            critChanceDisplay: document.getElementById("critChanceInfo"),
            critMultiplierDisplay: document.getElementById("critMultiplierInfo"),
            progressBar: document.getElementById("progressBar"),
            progressText: document.getElementById("progressText"),
            levelAnnounce: document.getElementById("levelAnnounce"),
            gameTitle: document.getElementById("gameTitle"),
            upgradeClickBtn: document.getElementById("upgradeClickBtn"),
            upgradeHelperBtn: document.getElementById("upgradeHelperBtn"),
            upgradeCritChanceBtn: document.getElementById("upgradeCritChanceBtn"),
            upgradeCritMultBtn: document.getElementById("upgradeCritMultBtn"),
            upgradeHelperDmgBtn: document.getElementById("upgradeHelperDmgBtn"),
            gameOverScreen: document.getElementById("gameOverScreen"),
            finalScoreDisplay: document.getElementById("finalScore"),
            tooltip: document.getElementById("tooltip"),
            welcomeScreen: document.getElementById("welcomeScreen"),
            header: document.getElementById("header"),
            gameArea: document.getElementById("gameArea"),
            particlesCanvas: document.getElementById("particlesCanvas"),
            startBtn: document.getElementById("startBtn"),
            continueBtn: document.getElementById("continueBtn"),
            restartBtn: document.getElementById("restartBtn"),
            shareBtn: document.getElementById("shareBtn"),
            dailyRewardBtn: document.getElementById("dailyRewardBtn"),
            saveBtn: document.getElementById("saveBtn"),
            starsCanvas: document.getElementById('starsCanvas'),
            lavaCanvas: document.getElementById('lavaCanvas'),
            iceCanvas: document.getElementById('iceCanvas'),
            bioCanvas: document.getElementById('bioCanvas')
        };

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        let missingElements = [];
        Object.entries(DOMElements).forEach(([name, element]) => {
            if (!element) missingElements.push(name);
        });
        
        if (missingElements.length > 0) {
            console.error("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —ç–ª–µ–º–µ–Ω—Ç—ã:", missingElements.join(", "));
            return;
        }

        // –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        const {
            coinsDisplay, clickPowerDisplay, helperTimerDisplay, 
            critChanceDisplay, critMultiplierDisplay, progressBar, progressText,
            levelAnnounce, gameTitle, upgradeClickBtn, upgradeHelperBtn, 
            upgradeCritChanceBtn, upgradeCritMultBtn, upgradeHelperDmgBtn, 
            gameOverScreen, finalScoreDisplay, tooltip, welcomeScreen, header,
            gameArea, particlesCanvas, startBtn, continueBtn, restartBtn, shareBtn, dailyRewardBtn, saveBtn,
            starsCanvas, lavaCanvas, iceCanvas, bioCanvas
        } = DOMElements;

        // –ó–ê–ì–†–£–ó–ö–ê –°–û–•–†–ê–ù–ï–ù–ò–Ø –ü–†–ò –°–¢–ê–†–¢–ï
        loadGame();
        // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —É—Ä–æ–Ω –ø–æ –Ω–æ–≤–æ–π —Ñ–æ—Ä–º—É–ª–µ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
        clickPower = calculateClickPower();

        function resizeCanvases() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            [starsCanvas, lavaCanvas, iceCanvas, bioCanvas, particlesCanvas].forEach(c => {
                if (c) {
                    c.width = w;
                    c.height = h;
                }
            });
            if (currentLocation === 'mercury') initStars();
            if (currentLocation === 'venus') initLava();
            if (currentLocation === 'earth') initSnow();
            if (currentLocation === 'mars') initBio();
        }
        
        // === –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ß–ê–°–¢–ò–¶ - –°–ú–ï–©–ï–ù–ò–ï –í–ü–†–ê–í–û –ò –ó–ê–ú–ï–î–õ–ï–ù–ò–ï ===
        const particles = [];
        function createExplosion(block) {
            const rect = block.getBoundingClientRect();
            // –°–º–µ—â–∞–µ–º —Ü–µ–Ω—Ç—Ä –≤—ã–ª–µ—Ç–∞ —á–∞—Å—Ç–∏—Ü –≤ –ø—Ä–∞–≤—É—é —Å—Ç–æ—Ä–æ–Ω—É –∑–∞ –∫—Ä–∞–π —ç–∫—Ä–∞–Ω–∞
            const centerX = window.innerWidth + 100; // –ó–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —ç–∫—Ä–∞–Ω–∞ —Å–ø—Ä–∞–≤–∞
            const centerY = rect.top + rect.height / 2;
            const theme = locations[currentLocation];
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: centerX,
                    y: centerY,
                    size: Math.random() * 4 + 1,
                    // –£–º–µ–Ω—å—à–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –≤ 2 —Ä–∞–∑–∞
                    speedX: (Math.random() - 0.5) * 4, // –±—ã–ª–æ 8
                    speedY: (Math.random() - 0.5) * 4, // –±—ã–ª–æ 8
                    color: theme.blockColors[Math.floor(Math.random() * theme.blockColors.length)],
                    life: 1
                });
            }
        }

        function animateParticles() {
            if (!gameActive || !particlesCanvas) return;
            const ctx = particlesCanvas.getContext('2d');
            ctx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life -= 0.01;
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            if (gameActive) {
                requestAnimationFrame(animateParticles);
            }
        }

        // === –§–û–ù–û–í–´–ï –ê–ù–ò–ú–ê–¶–ò–ò (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ===
        function initStars() {
            stars = [];
            const centerX = starsCanvas.width / 2;
            const centerY = starsCanvas.height / 2;
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1.5;
                const distance = Math.random() * Math.max(starsCanvas.width, starsCanvas.height) * 0.8;
                stars.push({
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance,
                    size: Math.random() * 3 + 0.5,
                    speed: speed,
                    angle: angle,
                    opacity: Math.random() * 0.8 + 0.2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed
                });
            }
        }
        
        function animateStars() {
            const ctx = starsCanvas.getContext('2d');
            ctx.fillStyle = 'rgba(11, 11, 29, 0.1)';
            ctx.fillRect(0, 0, starsCanvas.width, starsCanvas.height);
            const centerX = starsCanvas.width / 2;
            const centerY = starsCanvas.height / 2;
            ctx.fillStyle = '#fff';
            stars.forEach(star => {
                star.x += star.vx;
                star.y += star.vy;
                if (star.x < -50 || star.x > starsCanvas.width + 50 || 
                    star.y < -50 || star.y > starsCanvas.height + 50) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1.5;
                    star.x = centerX;
                    star.y = centerY;
                    star.vx = Math.cos(angle) * speed;
                    star.vy = Math.sin(angle) * speed;
                    star.size = Math.random() * 3 + 0.5;
                    star.opacity = Math.random() * 0.8 + 0.2;
                }
                ctx.globalAlpha = star.opacity;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            if (currentLocation === 'mercury') {
                requestAnimationFrame(animateStars);
            }
        }

        function initLava() {
            lavaParticles = [];
            for (let i = 0; i < 60; i++) {
                lavaParticles.push({
                    x: Math.random() * lavaCanvas.width,
                    y: lavaCanvas.height + Math.random() * 100,
                    size: Math.random() * 8 + 3,
                    speed: Math.random() * 3 + 1,
                    color: `hsl(${Math.random() * 20 + 10}, 80%, ${Math.random() * 30 + 50}%)`,
                    sway: (Math.random() - 0.5) * 0.5
                });
            }
        }
        
        function animateLava() {
            const ctx = lavaCanvas.getContext('2d');
            ctx.fillStyle = 'rgba(62, 39, 35, 0.1)';
            ctx.fillRect(0, 0, lavaCanvas.width, lavaCanvas.height);
            lavaParticles.forEach(p => {
                p.y -= p.speed;
                p.x += p.sway;
                if (p.y < -20) {
                    p.y = lavaCanvas.height + 20;
                    p.x = Math.random() * lavaCanvas.width;
                    p.speed = Math.random() * 3 + 1;
                    p.sway = (Math.random() - 0.5) * 0.5;
                }
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            if (currentLocation === 'venus') {
                requestAnimationFrame(animateLava);
            }
        }

        function initSnow() {
            snowflakes = [];
            for (let i = 0; i < 80; i++) {
                snowflakes.push({
                    x: Math.random() * iceCanvas.width,
                    y: Math.random() * -iceCanvas.height,
                    size: Math.random() * 5 + 2,
                    speed: Math.random() * 2 + 0.5,
                    sway: Math.random() * 0.03,
                    swaySpeed: Math.random() * 0.05 + 0.02
                });
            }
        }
        
        function animateSnow() {
            const ctx = iceCanvas.getContext('2d');
            ctx.fillStyle = 'rgba(13, 71, 161, 0.05)';
            ctx.fillRect(0, 0, iceCanvas.width, iceCanvas.height);
            snowflakes.forEach(f => {
                f.y += f.speed;
                f.x += Math.sin(f.y * f.swaySpeed) * f.sway;
                if (f.y > iceCanvas.height) {
                    f.y = -10;
                    f.x = Math.random() * iceCanvas.width;
                    f.speed = Math.random() * 2 + 0.5;
                }
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
                ctx.fill();
            });
            if (currentLocation === 'earth') {
                requestAnimationFrame(animateSnow);
            }
        }

        function initBio() {
            bioDots = [];
            for (let i = 0; i < 50; i++) {
                bioDots.push({
                    x: Math.random() * bioCanvas.width,
                    y: Math.random() * bioCanvas.height,
                    size: Math.random() * 4 + 1,
                    speedX: (Math.random() - 0.5) * 1.5,
                    speedY: (Math.random() - 0.5) * 1.5,
                    color: `hsl(${Math.random() * 60 + 90}, 70%, 60%)`,
                    directionChange: Math.random() * 0.02 + 0.01,
                    changeCounter: 0
                });
            }
        }
        
        function animateBio() {
            const ctx = bioCanvas.getContext('2d');
            ctx.fillStyle = 'rgba(27, 94, 32, 0.05)';
            ctx.fillRect(0, 0, bioCanvas.width, bioCanvas.height);
            bioDots.forEach(d => {
                d.changeCounter++;
                if (d.changeCounter > 60) {
                    d.speedX += (Math.random() - 0.5) * d.directionChange;
                    d.speedY += (Math.random() - 0.5) * d.directionChange;
                    d.changeCounter = 0;
                }
                d.speedX = Math.max(-1.5, Math.min(1.5, d.speedX));
                d.speedY = Math.max(-1.5, Math.min(1.5, d.speedY));
                d.x += d.speedX;
                d.y += d.speedY;
                if (d.x < 0 || d.x > bioCanvas.width) d.speedX *= -1;
                if (d.y < 0 || d.y > bioCanvas.height) d.speedY *= -1;
                ctx.fillStyle = d.color;
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                ctx.fill();
            });
            if (currentLocation === 'mars') {
                requestAnimationFrame(animateBio);
            }
        }

        const locations = {
            mercury: { name: "‚òø –ú–µ—Ä–∫—É—Ä–∏–π", color: "#bb86fc", coinColor: "#a0d2ff", borderColor: "#4a55e0", blockColors: ['#2962ff', '#4fc3f7', '#bb86fc', '#f8bbd0'] },
            venus: { name: "‚ôÄ –í–µ–Ω–µ—Ä–∞", color: "#ffab91", coinColor: "#a0d2ff", borderColor: "#ff5722", blockColors: ['#ff5722', '#ff9800', '#ff5722', '#e91e63'] },
            earth: { name: "‚ôÅ –ó–µ–º–ª—è", color: "#80deea", coinColor: "#a0d2ff", borderColor: "#0288d1", blockColors: ['#0288d1', '#29b6f6', '#00bcd4', '#00e5ff'] },
            mars: { name: "‚ôÇ –ú–∞—Ä—Å", color: "#a5d6a7", coinColor: "#a0d2ff", borderColor: "#388e3c", blockColors: ['#388e3c', '#66bb6a', '#9ccc65', '#d4e157'] },
            jupiter: { name: "‚ôÉ –Æ–ø–∏—Ç–µ—Ä", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            saturn: { name: "‚ôÑ –°–∞—Ç—É—Ä–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            uranus: { name: "‚ôÖ –£—Ä–∞–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            neptune: { name: "‚ôÜ –ù–µ–ø—Ç—É–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] },
            pluto: { name: "‚ôá –ü–ª—É—Ç–æ–Ω", color: "#ce93d8", coinColor: "#a0d2ff", borderColor: "#7b1fa2", blockColors: ['#7b1fa2', '#9c27b0', '#ab47bc', '#e1bee7'] }
        };

        // === –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ü–†–û–ì–†–ï–°–°–ê –í –ê–°–¢–†–û–ù–û–ú–ò–ß–ï–°–ö–ò–• –ï–î–ò–ù–ò–¶–ê–• ===
        function updateProgressBar() {
            const currentReq = locationRequirements[currentLocation];
            const nextLocation = currentReq.nextLocation;
            
            if (nextLocation) {
                const nextReq = locationRequirements[nextLocation];
                const progress = totalDamageDealt - currentReq.damageRequired;
                const requiredForNext = nextReq.damageRequired - currentReq.damageRequired;
                const percentage = Math.min(100, (progress / requiredForNext) * 100);
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –∞—Å—Ç—Ä–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –µ–¥–∏–Ω–∏—Ü—ã
                const currentAU = currentReq.au + (progress / AU_TO_DAMAGE);
                const targetAU = nextReq.au;
                
                progressBar.style.width = percentage + '%';
                progressText.textContent = `–ü—Ä–æ–≥—Ä–µ—Å—Å: ${currentAU.toFixed(5)}/${targetAU.toFixed(5)} –∞.–µ.`;
            } else {
                // –§–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–∫–∞—Ü–∏—è
                progressBar.style.width = '100%';
                progressText.textContent = '–î–æ—Å—Ç–∏–≥–Ω—É—Ç –∫—Ä–∞–π –°–æ–ª–Ω–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã!';
            }
        }

        function checkLocationUpgrade() {
            const currentReq = locationRequirements[currentLocation];
            const nextLocation = currentReq.nextLocation;
            
            if (nextLocation && totalDamageDealt >= locationRequirements[nextLocation].damageRequired) {
                setLocation(nextLocation);
                showTooltip(`–û—Ç–∫—Ä—ã—Ç–∞ –ª–æ–∫–∞—Ü–∏—è: ${locations[nextLocation].name}!`);
                setTimeout(hideTooltip, 3000);
            }
            
            updateProgressBar();
        }

        // === –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –¢–ï–ö–°–¢–ê –£–†–û–ù–ê –ò –ë–û–ù–£–°–û–í ===
        function createDamageText(damage, block, color = '#ff4444') {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'damage-text';
            text.textContent = `-${damage}`;
            text.style.color = color;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ, —á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç –±—ã–ª –≤–∏–¥–µ–Ω
            let left = rect.left + rect.width / 2;
            let top = rect.top;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç –Ω–µ –≤—ã—Ö–æ–¥–∏–ª –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã —ç–∫—Ä–∞–Ω–∞
            const textWidth = 100; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è —à–∏—Ä–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            
            document.body.appendChild(text);
            let opacity = 1;
            let yPos = parseInt(text.style.top);
            function animate() {
                opacity -= 0.02;
                yPos -= 2;
                text.style.opacity = opacity;
                text.style.top = yPos + 'px';
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    if (text.parentNode) {
                        document.body.removeChild(text);
                    }
                }
            }
            animate();
        }

        function showComboText(combo, bonus, block) {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'combo-text';
            text.textContent = `–ö–æ–º–±–æ x${combo}! +${bonus}`;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
            let left = rect.left + rect.width / 2;
            let top = rect.top;
            
            const textWidth = 150;
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            
            document.body.appendChild(text);
            setTimeout(() => {
                if (text.parentNode) {
                    document.body.removeChild(text);
                }
            }, 1000);
        }

        function showRewardText(reward, block) {
            const rect = block.getBoundingClientRect();
            const text = document.createElement('div');
            text.className = 'reward-text';
            text.textContent = `+${reward} üíé`;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
            let left = rect.left + rect.width / 2;
            let top = rect.top + rect.height / 2;
            
            const textWidth = 120;
            if (left < textWidth / 2) left = textWidth / 2;
            if (left > window.innerWidth - textWidth / 2) left = window.innerWidth - textWidth / 2;
            if (top < 50) top = 50;
            
            text.style.left = left + 'px';
            text.style.top = top + 'px';
            
            document.body.appendChild(text);
            setTimeout(() => {
                if (text.parentNode) {
                    document.body.removeChild(text);
                }
            }, 1500);
        }

        // === –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –ò–ì–†–´ (–±–µ–∑ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π) ===
        function setLocation(loc) {
            document.querySelectorAll('.location').forEach(el => el.classList.remove('active'));
            document.getElementById(`location-${loc}`).classList.add('active');
            currentLocation = loc;
            const theme = locations[loc];
            if (gameTitle) gameTitle.textContent = theme.name;
            if (header) header.style.borderColor = theme.borderColor;
            switch(loc) {
                case 'mercury':
                    initStars();
                    animateStars();
                    break;
                case 'venus':
                    initLava();
                    animateLava();
                    break;
                case 'earth':
                    initSnow();
                    animateSnow();
                    break;
                case 'mars':
                    initBio();
                    animateBio();
                    break;
                case 'jupiter':
                case 'saturn':
                case 'uranus':
                case 'neptune':
                case 'pluto':
                    break;
            }
            if (levelAnnounce) {
                levelAnnounce.textContent = theme.name;
                levelAnnounce.style.color = theme.color;
                levelAnnounce.style.opacity = "1";
                setTimeout(() => {
                    levelAnnounce.style.opacity = "0";
                }, 2000);
            }
            updateProgressBar();
        }

        function updateCoins() {
            if (coinsDisplay) coinsDisplay.textContent = `–ö—Ä–∏—Å—Ç–∞–ª–ª—ã: ${Math.floor(coins).toLocaleString()}`;
            updateUpgradeButtons();
        }

        // –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–ë–ù–û–í–õ–ï–ù–ò–Ø –ö–ù–û–ü–û–ö –° –ü–†–û–ü–û–†–¶–ò–û–ù–ê–õ–¨–ù–´–ú –†–û–°–¢–û–ú –°–¢–û–ò–ú–û–°–¢–ò
        function updateUpgradeButtons() {
            const clickCost = Math.floor(baseClickUpgradeCost * Math.pow(1.5, clickUpgradeLevel));
            if (upgradeClickBtn) {
                upgradeClickBtn.querySelector('.upgrade-cost').textContent = clickCost.toLocaleString();
                if (coins >= clickCost) {
                    upgradeClickBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeClickBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            
            // –û–ë–ù–û–í–õ–ï–ù–ù–´–ï –°–¢–û–ò–ú–û–°–¢–ò –î–õ–Ø –í–°–ï–• –£–õ–£–ß–®–ï–ù–ò–ô
            const helperCost = Math.floor(baseHelperUpgradeCost * Math.pow(1.4, helperUpgradeLevel));
            if (upgradeHelperBtn) {
                upgradeHelperBtn.querySelector('.upgrade-cost').textContent = helperCost.toLocaleString();
                if (coins >= helperCost && !helperActive) {
                    upgradeHelperBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeHelperBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            
            const critChanceCost = Math.floor(baseCritChanceCost * Math.pow(1.3, Math.floor(critChance * 100)));
            if (upgradeCritChanceBtn) {
                upgradeCritChanceBtn.querySelector('.upgrade-cost').textContent = critChanceCost.toLocaleString();
                if (coins >= critChanceCost) {
                    upgradeCritChanceBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeCritChanceBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            
            const critMultiplierCost = Math.floor(baseCritMultiplierCost * Math.pow(1.25, Math.floor((critMultiplier - 2) * 5)));
            if (upgradeCritMultBtn) {
                upgradeCritMultBtn.querySelector('.upgrade-cost').textContent = critMultiplierCost.toLocaleString();
                if (coins >= critMultiplierCost) {
                    upgradeCritMultBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeCritMultBtn.className = "upgrade-btn btn-unavailable";
                }
            }
            
            const helperDmgCost = Math.floor(baseHelperDmgCost * Math.pow(helperUpgradeMultiplier, helperUpgradeLevel));
            if (upgradeHelperDmgBtn) {
                upgradeHelperDmgBtn.querySelector('.upgrade-cost').textContent = helperDmgCost.toLocaleString();
                if (coins >= helperDmgCost) {
                    upgradeHelperDmgBtn.className = "upgrade-btn btn-available";
                } else {
                    upgradeHelperDmgBtn.className = "upgrade-btn btn-unavailable";
                }
            }
        }

        function buyClickPower() {
            const cost = Math.floor(baseClickUpgradeCost * Math.pow(1.5, clickUpgradeLevel));
            if (coins >= cost) {
                coins -= cost;
                clickUpgradeLevel += 1;
                
                clickPower = calculateClickPower();
                
                gameMetrics.upgradesBought++;
                updateCoins();
                if (clickPowerDisplay) clickPowerDisplay.textContent = `–°–∏–ª–∞: ${Math.round(clickPower)}`;
                playSound('upgradeSound');
                showTooltip(`–°–∏–ª–∞ —É–≤–µ–ª–∏—á–µ–Ω–∞!<br>–¢–µ–ø–µ—Ä—å: ${Math.round(clickPower)}`);
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }

        function buyHelper() {
            const cost = Math.floor(baseHelperUpgradeCost * Math.pow(1.4, helperUpgradeLevel));
            if (coins >= cost && !helperActive) {
                coins -= cost;
                activateHelper();
                updateCoins();
                saveGame();
            }
        }

        function buyCritChance() {
            const cost = Math.floor(baseCritChanceCost * Math.pow(1.3, Math.floor(critChance * 100)));
            if (coins >= cost) {
                coins -= cost;
                critChance = Math.min(1.0, critChance + 0.01);
                gameMetrics.upgradesBought++;
                updateCoins();
                if (critChanceDisplay) critChanceDisplay.textContent = `–ö—Ä–∏—Ç: ${(critChance * 100).toFixed(0)}%`;
                playSound('upgradeSound');
                showTooltip(`–®–∞–Ω—Å –∫—Ä–∏—Ç–∞ +1%!<br>–¢–µ–ø–µ—Ä—å: ${(critChance * 100).toFixed(0)}%`);
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }

        function buyCritMultiplier() {
            const cost = Math.floor(baseCritMultiplierCost * Math.pow(1.25, Math.floor((critMultiplier - 2) * 5)));
            if (coins >= cost) {
                coins -= cost;
                critMultiplier += 0.2;
                gameMetrics.upgradesBought++;
                updateCoins();
                if (critMultiplierDisplay) critMultiplierDisplay.textContent = `–ú–Ω–æ–∂: x${critMultiplier.toFixed(1)}`;
                playSound('upgradeSound');
                showTooltip(`–ú–Ω–æ–∂–∏—Ç–µ–ª—å –∫—Ä–∏—Ç–∞ +0.2x!<br>–¢–µ–ø–µ—Ä—å: x${critMultiplier.toFixed(1)}`);
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }

        function buyHelperDamage() {
            const cost = Math.floor(baseHelperDmgCost * Math.pow(helperUpgradeMultiplier, helperUpgradeLevel));
            if (coins >= cost) {
                coins -= cost;
                helperUpgradeLevel += 1;
                gameMetrics.upgradesBought++;
                updateCoins();
                playSound('upgradeSound');
                showTooltip(`–£—Ä–æ–Ω Bobo +20%!<br>–£—Ä–æ–≤–µ–Ω—å: ${helperUpgradeLevel}`);
                setTimeout(hideTooltip, 1500);
                saveGame();
            }
        }

        function activateHelper() {
            if (helperActive) return;
            helperActive = true;
            helperTimeLeft = helperDuration;
            gameMetrics.upgradesBought++;
            helperInterval = setInterval(() => {
                if (helperActive && currentBlock && gameActive) {
                    helperAttack();
                }
            }, 1500);
            const helperTimer = setInterval(() => {
                if (!helperActive) {
                    clearInterval(helperTimer);
                    return;
                }
                helperTimeLeft -= 1000;
                updateHelperTimer();
                if (helperTimeLeft <= 0) {
                    helperActive = false;
                    clearInterval(helperInterval);
                    clearInterval(helperTimer);
                    updateHelperTimer();
                    updateUpgradeButtons();
                    showTooltip('Bobo –∑–∞–∫–æ–Ω—á–∏–ª —Ä–∞–±–æ—Ç—É!');
                    setTimeout(hideTooltip, 1500);
                }
            }, 1000);
            updateUpgradeButtons();
            showTooltip('Bobo –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –Ω–∞ 1 –º–∏–Ω—É—Ç—É!');
            setTimeout(hideTooltip, 1500);
        }

        function helperAttack() {
            if (!currentBlock || !helperActive) return;
            createHelperEffect();
            const baseHelperDmg = clickPower * (1 + helperDamageBonus);
            const upgradedHelperDmg = baseHelperDmg * (1 + helperUpgradeLevel * 0.2);
            currentBlockHealth -= upgradedHelperDmg;
            totalDamageDealt += upgradedHelperDmg;
            gameMetrics.totalClicks++;
            createDamageText(Math.round(upgradedHelperDmg), currentBlock, '#69f0ae');
            checkLocationUpgrade();
            if (currentBlockHealth <= 0) {
                destroyBlock(currentBlock);
            } else {
                currentBlock.textContent = Math.floor(currentBlockHealth);
                updateCracks(currentBlock, currentBlockHealth);
            }
        }

        function createHelperEffect() {
            if (!currentBlock) return;
            const blockRect = currentBlock.getBoundingClientRect();
            const helperX = blockRect.left + Math.random() * blockRect.width;
            const helperY = blockRect.top - 50;
            const helper = document.createElement('div');
            helper.className = 'helper';
            helper.style.left = helperX + 'px';
            helper.style.top = helperY + 'px';
            document.body.appendChild(helper);
            const beam = document.createElement('div');
            beam.className = 'helper-beam';
            beam.style.left = (helperX + 20) + 'px';
            beam.style.top = (helperY + 40) + 'px';
            document.body.appendChild(beam);
            setTimeout(() => {
                if (helper.parentNode) document.body.removeChild(helper);
                if (beam.parentNode) document.body.removeChild(beam);
            }, 1000);
        }

        function updateHelperTimer() {
            if (helperTimerDisplay) {
                if (helperActive) {
                    const seconds = Math.ceil(helperTimeLeft / 1000);
                    helperTimerDisplay.textContent = `Bobo: ${seconds}—Å`;
                } else {
                    helperTimerDisplay.textContent = `Bobo: ‚Äî`;
                }
            }
        }

        function updateCracks(block, health) {
            if (!block) return;
            const existingCrack = block.querySelector('.crack-overlay');
            if (existingCrack) {
                block.removeChild(existingCrack);
            }
            const maxHealth = parseInt(block.dataset.maxHealth);
            const damageRatio = 1 - (health / maxHealth);
            if (damageRatio > 0.7) {
                addCracks(block, 'crack-3');
            } else if (damageRatio > 0.4) {
                addCracks(block, 'crack-2');
            } else if (damageRatio > 0.1) {
                addCracks(block, 'crack-1');
            }
        }

        function addCracks(block, crackLevel) {
            const crackOverlay = document.createElement('div');
            crackOverlay.className = `crack-overlay ${crackLevel}`;
            block.appendChild(crackOverlay);
        }

        function playSound(soundId) {
            const sound = document.getElementById(soundId);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => {});
            }
        }

        function hitBlock(block, damage) {
            if (!gameActive) return;
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            playSound('clickSound');
            block.style.transform = 'translateX(-50%) scale(0.85)';
            setTimeout(() => {
                block.style.transform = 'translateX(-50%) scale(1)';
            }, 100);
            let finalDamage = Math.round(damage);
            let isCrit = false;
            if (Math.random() < critChance) {
                finalDamage = Math.round(damage * critMultiplier);
                isCrit = true;
            }
            currentBlockHealth -= finalDamage;
            totalDamageDealt += finalDamage;
            gameMetrics.totalClicks++;
            createDamageText(finalDamage, block, isCrit ? '#FFD700' : '#ff4444');
            checkLocationUpgrade();
            if (currentBlockHealth <= 0) {
                destroyBlock(block);
            } else {
                block.textContent = Math.floor(currentBlockHealth);
                updateCracks(block, currentBlockHealth);
            }
        }

        function destroyBlock(block) {
            const now = Date.now();
            if (now - lastDestroyTime < COMBO_TIME_WINDOW) {
                comboCount++;
            } else {
                comboCount = 1;
            }
            lastDestroyTime = now;
            
            const baseReward = 25 + (locationRequirements[currentLocation].damageRequired / 500);
            let reward = Math.floor(baseReward * balanceConfig.rewardMultiplier);
            
            const randomBonus = balanceConfig.randomBonusRange.min + 
                               Math.random() * (balanceConfig.randomBonusRange.max - balanceConfig.randomBonusRange.min);
            reward = Math.floor(reward * randomBonus);
            
            let isRare = false;
            let rareType = null;
            for (const type in rareBlocks) {
                if (block.classList.contains(rareBlocks[type].className)) {
                    isRare = true;
                    rareType = type;
                    reward = Math.floor(reward * rareBlocks[type].multiplier);
                    break;
                }
            }

            if (comboCount > 1) {
                const comboBonus = Math.floor(reward * (comboCount * balanceConfig.comboMultiplier));
                reward += comboBonus;
                showComboText(comboCount, comboBonus, block);
                playSound('comboSound');
            }
            coins += reward;
            gameMetrics.blocksDestroyed++;
            updateCoins();
            playSound('breakSound');
            showRewardText(reward, block);
            createExplosion(block);
            if (gameArea.contains(block)) {
                gameArea.removeChild(block);
            }
            currentBlock = null;
            currentBlockHealth = 0;
            
            setTimeout(() => {
                if (gameActive) {
                    createMovingBlock();
                }
            }, 500);
        }

        function getBlockSize() {
            const baseSize = isMobile ? 80 : 60;
            const locationBonus = locationRequirements[currentLocation].damageRequired / 10000;
            return Math.max(baseSize, 100 - locationBonus);
        }

        function createMovingBlock() {
            if (currentBlock && gameArea.contains(currentBlock)) {
                gameArea.removeChild(currentBlock);
            }
            
            const blockHealth = calculateBlockHealth();
            currentBlockHealth = blockHealth;
            
            const block = document.createElement("div");
            block.className = "moving-block";
            const size = getBlockSize();
            block.style.width = size + "px";
            block.style.height = size + "px";
            block.style.bottom = "0px";
            block.dataset.maxHealth = blockHealth;
            
            const theme = locations[currentLocation];
            const colorIndex = Math.floor(Math.random() * theme.blockColors.length);
            
            let isRare = false;
            let rareType = null;
            const potentialRareType = getRareBlockType();
            if (potentialRareType) {
                isRare = true;
                rareType = potentialRareType;
                const rareBlock = rareBlocks[rareType];
                block.classList.add(rareBlock.className);
                currentBlockHealth = Math.floor(currentBlockHealth * rareBlock.healthMultiplier);
                block.textContent = currentBlockHealth;
                block.innerHTML = `üåü<div style="font-size: 0.7em; margin-top: 5px;">${rareBlock.name}</div>`;
                announceRareBlock(rareBlock.name);
            } else {
                block.style.background = `linear-gradient(135deg, ${theme.blockColors[colorIndex]}, ${theme.blockColors[(colorIndex + 1) % theme.blockColors.length]})`;
                block.style.boxShadow = `0 0 15px ${theme.blockColors[colorIndex]}`;
                block.style.border = `2px solid ${theme.borderColor}`;
                block.textContent = blockHealth;
            }
            
            const expectedClicks = getExpectedClicks(currentBlockHealth, clickPower);
            console.log(`–°–æ–∑–¥–∞–Ω –±–ª–æ–∫: –ó–¥–æ—Ä–æ–≤—å–µ=${currentBlockHealth}, –£—Ä–æ–Ω=${Math.round(clickPower)}, –û–∂–∏–¥–∞–µ—Ç—Å—è –∫–ª–∏–∫–æ–≤=${expectedClicks}`);
            
            block.addEventListener('click', () => hitBlock(block, clickPower));
            block.addEventListener('touchstart', (e) => {
                e.preventDefault();
                hitBlock(block, clickPower);
            }, { passive: false });
            
            gameArea.appendChild(block);
            currentBlock = block;
            animateBlock(block);
        }

        function animateBlock(block) {
            if (!gameActive) return;
            const speed = getCurrentSpeed();
            let position = parseInt(block.style.bottom) || 0;
            function move() {
                if (!gameActive || currentBlock !== block) return;
                position += speed / 30;
                block.style.bottom = position + "px";
                if (position > window.innerHeight) {
                    gameOver();
                    return;
                }
                requestAnimationFrame(move);
            }
            move();
        }

        function gameOver(customMessage = null) {
            gameActive = false;
            helperActive = false;
            if (helperInterval) clearInterval(helperInterval);
            const sessionTime = Date.now() - gameMetrics.startTime;
            console.log('üéÆ [–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –ö–ª–∏–∫–µ—Ä] –°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞:', {
                session: gameMetrics.sessions,
                duration_sec: Math.round(sessionTime / 1000),
                total_damage: totalDamageDealt,
                current_location: currentLocation,
                total_coins: coins,
                blocks_destroyed: gameMetrics.blocksDestroyed,
                upgrades_bought: gameMetrics.upgradesBought,
                total_clicks: gameMetrics.totalClicks
            });
            
            localStorage.setItem('gameSessions', gameMetrics.sessions.toString());
            
            if (currentBlock && gameArea.contains(currentBlock)) {
                gameArea.removeChild(currentBlock);
                currentBlock = null;
            }
            
            if (finalScoreDisplay) {
                finalScoreDisplay.textContent = `–í—Å–µ–≥–æ —É—Ä–æ–Ω–∞: ${Math.floor(totalDamageDealt).toLocaleString()}`;
            }
            
            if (gameOverScreen) {
                gameOverScreen.style.display = "flex";
            }
            
            if (customMessage) {
                const h2 = gameOverScreen.querySelector('h2');
                if (h2) h2.textContent = customMessage;
            }
            
            saveGame();
        }

        function shareResult() {
            const shareText = `üéÆ –Ø –Ω–∞–Ω–µ—Å ${Math.floor(totalDamageDealt).toLocaleString()} —É—Ä–æ–Ω–∞ –∏ —Å–æ–±—Ä–∞–ª ${Math.floor(coins)} –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –≤ –ö–æ—Å–º–∏—á–µ—Å–∫–æ–º –ö–ª–∏–∫–µ—Ä–µ! üåå
–°–º–æ–∂–µ—à—å –ø–æ–±–∏—Ç—å –º–æ–π —Ä–µ–∫–æ—Ä–¥?`;
            if (navigator.share) {
                navigator.share({
                    title: '–ú–æ–π —Ä–µ–∫–æ—Ä–¥ –≤ –ö–æ—Å–º–∏—á–µ—Å–∫–æ–º –ö–ª–∏–∫–µ—Ä–µ!',
                    text: shareText
                }).then(() => {
                    coins += 50;
                    updateCoins();
                    showTooltip('+50 –ö—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –∑–∞ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ!');
                    setTimeout(hideTooltip, 2000);
                    saveGame();
                });
            } else {
                navigator.clipboard.writeText(shareText).then(() => {
                    alert('–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω! –ü–æ–¥–µ–ª–∏—Å—å —Å –¥—Ä—É–∑—å—è–º–∏!');
                    coins += 50;
                    updateCoins();
                    saveGame();
                });
            }
        }

        function showTooltip(text) {
            if (tooltip) {
                tooltip.innerHTML = text;
                tooltip.style.opacity = "1";
            }
        }

        function hideTooltip() {
            if (tooltip) tooltip.style.opacity = "0";
        }

        // –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –°–¢–ê–†–¢–ê –ò–ì–†–´
        function startGame(reset = true) {
            if (reset) {
                // –°–ë–†–ê–°–´–í–ê–ï–ú –í–°–ï –ü–ê–†–ê–ú–ï–¢–†–´ –ü–ï–†–ï–î –ù–ê–ß–ê–õ–û–ú –ù–û–í–û–ô –ò–ì–†–´
                coins = 0;
                totalDamageDealt = 0;
                currentLocation = 'mercury';
                clickPower = 1;
                clickUpgradeLevel = 0;
                helperUpgradeLevel = 0;
                helperDamageBonus = 0.3;
                critChance = 0.01;
                critMultiplier = 2.0;
                helperActive = false;
                helperTimeLeft = 0;
            }
            
            if (helperInterval) {
                clearInterval(helperInterval);
                helperInterval = null;
            }
            
            gameArea.innerHTML = "";
            
            if (welcomeScreen) {
                welcomeScreen.style.display = "none";
            }
            
            gameActive = true;
            comboCount = 0;
            lastDestroyTime = 0;
            
            gameMetrics.startTime = Date.now();
            gameMetrics.blocksDestroyed = 0;
            gameMetrics.upgradesBought = 0;
            gameMetrics.totalClicks = 0;
            
            updateCoins();
            updateProgressBar();
            updateUpgradeButtons();
            setLocation(currentLocation);
            animateParticles();
            
            setTimeout(() => createMovingBlock(), 500);
        }

        function continueGame() {
            startGame(false); // –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        }

        function restartGame() {
            coins = 0;
            totalDamageDealt = 0;
            currentLocation = 'mercury';
            clickPower = 1;
            clickUpgradeLevel = 0;
            helperUpgradeLevel = 0;
            helperDamageBonus = 0.3;
            critChance = 0.01;
            critMultiplier = 2.0;
            helperActive = false;
            helperTimeLeft = 0;
            
            if (helperInterval) {
                clearInterval(helperInterval);
                helperInterval = null;
            }
            
            gameArea.innerHTML = "";
            
            if (gameOverScreen) gameOverScreen.style.display = "none";
            
            gameMetrics.startTime = Date.now();
            gameMetrics.blocksDestroyed = 0;
            gameMetrics.upgradesBought = 0;
            gameMetrics.totalClicks = 0;
            
            setLocation('mercury');
            
            updateCoins();
            updateProgressBar();
            updateUpgradeButtons();
            
            animateParticles();
            
            saveGame();
            
            gameActive = true;
            setTimeout(() => createMovingBlock(), 500);
        }

        function showStartError() {
            showTooltip("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
            setTimeout(hideTooltip, 3000);
        }

        // === –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ===
        if (startBtn) {
            startBtn.addEventListener('click', function() {
                try {
                    startGame(true);
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            });
            startBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                try {
                    startGame(true);
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            }, { passive: false });
        }

        if (continueBtn) {
            continueBtn.addEventListener('click', function() {
                try {
                    continueGame();
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            });
            continueBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                try {
                    continueGame();
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ –∏–≥—Ä—ã:", error);
                    showStartError();
                }
            }, { passive: false });
        }

        // –î–æ–±–∞–≤–ª—è–µ–º touch –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ —É–ª—É—á—à–µ–Ω–∏–π
        function addMobileButtonHandlers(button, handler) {
            if (button) {
                button.addEventListener('click', handler);
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    handler();
                }, { passive: false });
            }
        }

        addMobileButtonHandlers(upgradeClickBtn, buyClickPower);
        addMobileButtonHandlers(upgradeHelperBtn, buyHelper);
        addMobileButtonHandlers(upgradeCritChanceBtn, buyCritChance);
        addMobileButtonHandlers(upgradeCritMultBtn, buyCritMultiplier);
        addMobileButtonHandlers(upgradeHelperDmgBtn, buyHelperDamage);
        
        // –î–æ–±–∞–≤–ª—è–µ–º —Ç—É–ª—Ç–∏–ø—ã –¥–ª—è –∫–Ω–æ–ø–æ–∫
        if (upgradeClickBtn) {
            upgradeClickBtn.addEventListener('mouseenter', () => showTooltip('–°–∏–ª–∞ —É–¥–∞—Ä–∞<br>–ù–µ–ª–∏–Ω–µ–π–Ω—ã–π —Ä–æ—Å—Ç —É—Ä–æ–Ω–∞'));
            upgradeClickBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeHelperBtn) {
            upgradeHelperBtn.addEventListener('mouseenter', () => showTooltip('Bobo<br>–ê–≤—Ç–æ-–∞—Ç–∞–∫–∞ –Ω–∞ 1 –º–∏–Ω—É—Ç—É<br>+30% —É—Ä–æ–Ω–∞'));
            upgradeHelperBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeCritChanceBtn) {
            upgradeCritChanceBtn.addEventListener('mouseenter', () => showTooltip('–®–∞–Ω—Å –∫—Ä–∏—Ç–∞<br>+1% —à–∞–Ω—Å –∫—Ä–∏—Ç. —É—Ä–æ–Ω–∞'));
            upgradeCritChanceBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeCritMultBtn) {
            upgradeCritMultBtn.addEventListener('mouseenter', () => showTooltip('–ú–Ω–æ–∂–∏—Ç–µ–ª—å –∫—Ä–∏—Ç–∞<br>+0.2x –∫—Ä–∏—Ç. —É—Ä–æ–Ω–∞'));
            upgradeCritMultBtn.addEventListener('mouseleave', hideTooltip);
        }
        if (upgradeHelperDmgBtn) {
            upgradeHelperDmgBtn.addEventListener('mouseenter', () => showTooltip('–£—Ä–æ–Ω Bobo<br>+20% —É—Ä–æ–Ω–∞ –∑–∞ –∞–ø–≥—Ä–µ–π–¥'));
            upgradeHelperDmgBtn.addEventListener('mouseleave', hideTooltip);
        }
        
        addMobileButtonHandlers(restartBtn, restartGame);
        addMobileButtonHandlers(shareBtn, shareResult);
        addMobileButtonHandlers(dailyRewardBtn, checkDailyReward);
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        if (saveBtn) {
            saveBtn.addEventListener('click', saveGame);
            saveBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                saveGame();
            }, { passive: false });
        }

        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);
        updateCoins();
        updateProgressBar();
        setLocation(currentLocation);
        animateParticles();
    });

    // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –∂–µ—Å—Ç–æ–≤ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è
    document.addEventListener('touchstart', function(e) {
        if (e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener('gesturestart', function(e) {
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('gesturechange', function(e) {
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('gestureend', function(e) {
        e.preventDefault();
    }, { passive: false });
  </script>
</body>
</html>